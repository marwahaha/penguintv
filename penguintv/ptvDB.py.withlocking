from pysqlite2 import dbapi2 as sqlite
import feedparser
import time
import string
import sha
import urllib
from types import *
import threading
import ThreadPool
import os

import timeoutsocket
import smtplib
timeoutsocket.setDefaultSocketTimeout(20)

POLL_PERIOD=30*60
SUCCESS= 0
NOUSER = 1
NOFEED = 2
ALREADYEXISTS = 3
FAILURE = 4

NEW = 0
EXISTS = 1
MODIFIED = 2
DELETED = 3

F_ERROR       = 32
F_DOWNLOADING = 16   #**#
F_MEDIA       = 1
F_UNVIEWED    = 8
F_DOWNLOADED  = 4
F_NEW         = 2

from HTMLParser import HTMLParser
from formatter import NullFormatter

class HTMLtagParser(HTMLParser):
	def __init__(self):
		HTMLParser.__init__(self)
		self.text=''
		in_tag=0
		
	def handle_starttag(self, tag, attrs):
		"""Signal when we get to a tag.
		"""
		self.in_tag = 1###

	def end_a(self, attrs):
		"""Signal when we are out of the tag"""
		self.in_tag = 0#

	def handle_data(self, text):
		"""This is called everytime we get to text data (ie. not tags) """
		if self.in_tag and text!='' and self.text=='':
			self.text = text
			

class ptvDB:
	def __init__(self, polling_callback=None):#,username,password):
		try:
			home=os.getenv('HOME')
			os.stat(home+"/.penguintv")
		except:
			try:
				os.mkdir(home+"/.penguintv")
			except:
				raise DBError, "error creating directories: "+home+"/.penguintv"
		try:	
			self.db=sqlite.connect(home+"/.penguintv/penguintv.db", isolation_level=None)
		except:
			raise DBError,"error connecting to database"
		self.c = self.db.cursor()
#		self.in_threading=1
#		self.pool = ThreadPool.ThreadPool(5)
		self.db_lock = threading.RLock()
		if polling_callback==None:
			self.polling_callback=self._polling_callback
		else:
			self.polling_callback = polling_callback		

		try:
			self.c.execute(u'SELECT * FROM feeds')
		except:
			self.init_database()
			
		return

	def __del__(self):
		self.finish()
		#print "joining"
		#self.pool.joinAll()
		#print "done joining"
		#del self.pool
	#	self.c.close()
	#	self.db.close()
		
	def finish(self):
	#	self.db_lock.acquire()
	#	if self.pool.getThreadCount()>0:
	#		print "doop doop waiting to join"
#		self.pool.joinAll()
	#		print "done joining"
	#	del self.pool
	#		self.pool=ThreadPool.ThreadPool(5)
	#	self.db_lock.release()
		self.c.close()
		self.db.close()
		
	def init_database(self):
		self.db_lock.acquire()
		try:
			self.c.execute(u'DROP TABLE settings')
		except:
			pass	
			
		try:
			self.c.execute(u'DROP TABLE feeds')
		except:
			pass
			
		try:
			self.c.execute(u'DROP TABLE entries')
		except:
			pass
			
		try:
			self.c.execute(u'DROP TABLE media')
		except:
			pass
			
		self.c.execute(u"""CREATE TABLE settings
(
	data NOT NULL,
	value NOT NULL
);""")
		self.c.execute(u"""CREATE TABLE  feeds
(
    id INTEGER PRIMARY KEY,
    url NOT NULL,
    polled INT NOT NULL,
    pollfail BOOL NOT NULL,
    title  ,
    description  ,
    modified INT UNSIGNED NOT NULL,
    etag ,
    UNIQUE(url)
);""")
		self.c.execute(u"""CREATE TABLE entries
(
    id INTEGER  PRIMARY KEY,
        feed_id INT UNSIGNED NOT NULL,
        title ,
        creator  ,
        description,
        date DATE,
        guid ,
        link ,
	read BOOL NOT NULL,
        old BOOL NOT NULL,
        new BOOL NOT NULL,
        UNIQUE(id)
);""")
		self.c.execute(u"""CREATE TABLE  media
(
	id INTEGER  PRIMARY KEY,
	entry_id INTEGER UNSIGNED NOT NULL,
	url  NOT NULL,
	file ,
	mimetype ,
	download_status NOT NULL,
	viewed BOOL NOT NULL,
	keep BOOL NOT NULL,
	length,
	UNIQUE(id)
);
""")
		self.db_lock.release()		
		
	def get_setting(self, setting):
		self.db_lock.acquire()
		self.c.execute(u'SELECT value FROM settings WHERE data=?',(setting,))
		result = self.c.fetchone()
		self.db_lock.release()
		if result:
			return result[0]
		raise NoSetting, "no such setting"+str(setting)
		
	def set_setting(self, setting, value):
		self.db_lock.acquire()
		try:			
			self.get_setting(setting)
			self.c.execute(u'UPDATE settings SET value=? WHERE data=?',(value,setting))
		except NoSetting:
			self.c.execute(u'INSERT INTO settings (data, value) VALUES (?, ?)',(setting, value))
		self.db_lock.release()

	def insertURL(self, url):
		#if a feed with that url doesn't already exists, add it
		#since every time a url add a person is adding it, we can use this opportunity
		#to both associate a url with a user, and add new urls as needed
		self.db_lock.acquire()
		self.c.execute("""SELECT url FROM feeds WHERE url=?""",(url,))
		#on success, fetch will return the url itself
		if self.c.fetchone() != (url,):
			self.c.execute(u"""INSERT INTO feeds (id,url,polled,pollfail,modified) VALUES (NULL, ?,0,0, 0)""",(url,))
			self.c.execute("""SELECT id FROM feeds WHERE url=?""",(url,))
			feed_id = self.c.fetchone()
			feed_id = feed_id[0]
			#now poll the feed to seed it for the first time
			#no, don't use the tuple
			if self.poll_feed(feed_id) == NOFEED:
			#result = self.poll_feed(feed_id)
			#if result > 0:
				self.c.execute("""DELETE FROM feeds WHERE id=?""",(feed_id,))
				self.db_lock.release()
				return NOFEED #result
		else:
			self.c.execute("""SELECT id FROM feeds WHERE url=?""",(url,))
			feed_id = self.c.fetchone()
			feed_id = feed_id[0]
		self.db_lock.release()			
		return SUCCESS
		
	def delete_feed(self, feed_id):
		#check for valid entry
		self.db_lock.acquire()
		self.c.execute("""SELECT id FROM feeds WHERE id=?""",(feed_id,))
		result = self.c.fetchone()[0]

		if result != feed_id:
			self.db_lock.release()
			raise NoFeed,feed_id
		
		#delete the feed, its entries, and its media (this does not delete files)
		self.c.execute("""DELETE FROM feeds WHERE id=?""",(feed_id,))
		#result = self.c.fetchone()
		#print(result)
		#can't seem to do a multidelete...self.c.execute("""DELETE FROM media WHERE feed_id=?""",(feed_id,))
		self.c.execute('SELECT id FROM entries WHERE feed_id=?',(feed_id,))
		data=self.c.fetchall()
		if data: 
			dataList = [list(row) for row in data]
			for datum in dataList:
				self.c.execute('SELECT id FROM media WHERE entry_id=?',(datum[0],))
				media=self.c.fetchall()
				if media: 
					mediaList = [list(row) for row in media]
					for medium in mediaList:
						self.delete_media(int(medium[0]))
					self.c.execute('DELETE FROM media WHERE entry_id=?',(datum[0],))
		self.c.execute("""DELETE FROM entries WHERE feed_id=?""",(feed_id,))

		#TODO: also delete media
		self.db_lock.release()
		return SUCCESS
		
	def DEBUG_delete_all_media(self):
		self.db_lock.acquire()
		self.c.execute(u'UPDATE media SET download_status=0')
		self.db_lock.release()
		
	def delete_media(self, media_id):
		media = self.get_media(media_id)
#		print "deleting media: "+str(media)
		if media['file']==None:
			return
		self.set_media_download_status(media_id,0)
	#	print "deleting >"+str(media['file'])+"<"
		try:
			os.remove(media['file'])
		except os.error, detail:
			print "error deleting: "+str(detail)

	def delete_bad(self):
		self.db_lock.acquire()
		self.c.execute("""DELETE FROM feeds WHERE title IS NULL""")
		self.db_lock.release()
		return SUCCESS
		
	def poll_multiple(self, override=0):
		"""Polls multiple feeds multithreadedly, and returns a tuple
		representing the success of each poll based on the enum"""
		
		#print "active before start:" + str(threading.activeCount())
		#temporarily disabled threading because it's not working
		successes=[]

		#else if threaded==2:
			#try with ThreadPool
		#self.in_threading=1
		index = 0
		self.c.execute('SELECT id FROM feeds')
		data=self.c.fetchall()
		if data: 
			feeds = [list(row) for row in data]
		else:
			return
		pool = ThreadPool.ThreadPool(5)
		for feed in feeds:
			pool.queueTask(self.pool_poll_feed,(index,feed[0],override),self.polling_callback)
			index = index + 1
	#	print "waiting for threads"
		pool.joinAll(True,True)
		
		#self.in_threading=0
	#	print "we escape now"
		#return successes
	
	def pool_poll_feed(self,args):
		"""a wrapper function that returns the index along with the result
		so we can sort"""
		index=args[0]
		feed_id=args[1]
		override = 0
		try:
			override = args[2]
		except:
			pass
		result = self.poll_feed(feed_id,override)
		return (index,result)

	def _polling_callback(self, data):
		print "look a callback"
		print data
		
	def poll_feed(self, feed_id, override=0):
		#lock when we do database stuff
		self.db_lock.acquire()

		#test to see the poll status on this feed
		try:
			self.c.execute("""SELECT polled,pollfail FROM feeds WHERE id=?""",(feed_id,))
			mod_time,pollfail = self.c.fetchone()
		except:
			print 'error selecting basic info'
			self.db_lock.release()
			return NOFEED
		self.db_lock.release()
		if mod_time == "":
			return FAILURE
		
		cur_time = time.time()	
		#if cur_time - string.atof(mod_time) <= POLL_PERIOD and override==0:
		#	#pollfail was retrieved way up there
		#	if pollfail == 1:
		#		#raise NoFeed, feed_id
		#		return NOFEED
		#else: #ok it's time to poll.  
		#print("polling")
			#update polled so the program knows we at least tried.  Also
			#if the poll segfaults, the flag is set so it won't try again
		self.db_lock.acquire()
		self.c.execute("""UPDATE feeds SET polled=? WHERE id=?""", (cur_time,feed_id))
		#get url
		self.c.execute("""SELECT url,modified,etag FROM feeds WHERE id=?""",(feed_id,))
		url,modified,etag=self.c.fetchone()
		#get the new data
		self.db_lock.release()
		try:
			feedparser.disableWellFormedCheck=1
			#print str(url)+' m: '+str(modified)+' e: '+str(etag)
			if override == 1:
				data = feedparser.parse(url)
			else:
				if modified!=0:
					data = feedparser.parse(url,etag,time.localtime(modified))
				else:
					data = feedparser.parse(url,etag)
		except:
			return NOFEED
			
			#print(data)
		#this is extrememly simple code to see if things are ok
		if data.has_key('status'):
			if data['status'] == 304:
				self.db_lock.acquire()
				self.c.execute("""UPDATE entries SET new=0 WHERE feed_id=?""",(feed_id,))
				self.db_lock.release()
				return SUCCESS
			if data['status'] == 404:
				return NOFEED
				
		if len(data['channel']) == 0 or len(data['items']) == 0:
			self.db_lock.acquire()
			self.c.execute("""UPDATE feeds SET pollfail=1 WHERE id=?""",(feed_id,))
			self.db_lock.release()
			return NOFEED
			
			#else...
		#are we threading?
		self.db_lock.acquire()
		if override==1:
			self.c.execute("""DELETE FROM entries WHERE feed_id=?""",(feed_id,))

	        #to discover the old entries, first we mark everything as old
		#later, we well unset this flag for everything that is NEW,
		#MODIFIED, and EXISTS. anything still flagged should be deleted  
		self.c.execute("""UPDATE entries SET old=1 WHERE feed_id=?""",(feed_id,)) 
		self.c.execute("""UPDATE entries SET new=0 WHERE feed_id=?""",(feed_id,))
		#self.c.execute("SELECT new FROM entries WHERE feed_id=?",(feed_id,))
		#print self.c.fetchall()
		#also delete all related images
		#normalize results
		channel = data['channel']
		if channel.has_key('description') == 0:
			#print("creating empty description")
			channel['description']=""
		if len(channel['description']) > 128:
			channel['description'] = channel['description'][0:127]
		#print channel['description']
		channel['description']=self.encode_text(channel['description'])
		#print channel['description']
		#print 'desc set'
		if channel.has_key('title') == 0:
			if channel['description'] != "":
				#print("setting title to description")
				channel['title']=channel['description']
			else:
				channel['title']=url
		channel['title'] = self.encode_text(channel['title'])
		#print 'title set'
		#also set pollfail=0 since it worked, obviously
		if not data.has_key('etag'):
			data['etag']='0'
		if not data.has_key('modified'):
			modified='0'
		else:
			modified = time.mktime(data['modified'])
		#print 'about to commit'
		try:
			self.c.execute(u'SELECT * FROM feeds WHERE id=?',(feed_id,))
			exists=self.c.fetchone()
			if len(exists)==0: #don't change title
				self.c.execute("""UPDATE feeds SET description=?, modified=?, etag=?, pollfail=0 WHERE id=?""", (channel['description'], modified,data['etag'],feed_id))
			else:
				self.c.execute("""UPDATE feeds SET title=?, description=?, modified=?, etag=?, pollfail=0 WHERE id=?""", (channel['title'],channel['description'], modified,data['etag'],feed_id))
		except:
			#f = open("/var/log/penguintv.log",'a')
			#f.write("borked on: UPDATE feeds SET title="+str(channel['title'])+", description="+str(channel['description'])+", modified="+str(modified)+", etag="+str(data['etag'])+", pollfail=0 WHERE id="+str(feed_id))
			#f.close()				 
			self.db_lock.release()
			return NOFEED
		
			#populate the entries
		self.c.execute("""SELECT id,guid,link,title,description FROM entries WHERE feed_id=? order by date""",(feed_id,)) 
		existing_entries = self.c.fetchall()
		#print existing_entries
		#print existing_entries
		#for entry in existing_entries:
		#	print entry[0]['title']+' '+entry[0]['link']
		#ID=0,GUID=1,LINK=2,TITLE=3,BODY=4
		#we can't trust the dates inside the items for timing data
		#bad formats, no dates at all, and timezones screw things up
		#so I introduce a fake date which works for determining read and
		#unread article counts, and keeps the articles in order
		fake_time = time.time()#-len(data['items'])
		i=0
		
		try:
			if data['items'][0].has_key('modified_parsed') == 1:
				data['items'].sort(lambda x,y: int(time.mktime(y['modified_parsed'])-time.mktime(x['modified_parsed'])))
		except:
			try:
				if data['items'][0].has_key('created_parsed') == 1:
					data['items'].sort(lambda x,y: int(time.mktime(y['created_parsed'])-time.mktime(x['modified_parsed'])))
			except:	
				try:	
					if data['items'][0].has_key('date_parsed') == 1:
						data['items'].sort(lambda x,y: int(time.mktime(y['date_parsed'])-time.mktime(x['date_parsed'])))
				except:
					pass #I feel dirty.
		
		for item in data['items']:
			#do a lot of normalizing
			if item.has_key('content') == 0:   #ok so peter was right, 
				if item.has_key('description') == 1:   #content_encoded is where we should be
					item['body'] = item['description']   #but we can fall back on the description
				else:
					item['body'] = ''
			else:
				item['body'] = item['content'][0]['value']
			
			item['body']=self.encode_text(item['body'])
			
			#print item['body']
			if item.has_key('title') == 0:
				item['title']=item['description'][0:35]	
			elif item['title']=="":
				item['title']=item['description'][0:35]
				html_begin = string.find(item['title'],'<')
				if html_begin >= 0 and html_begin < 5: #in case it _begins_ with html, and the html is really early
					p = HTMLtagParser()
					p.feed(item['description'])
					item['title']=p.text[0:35]
			
				elif html_begin > 5: #in case there's html within 35 chars...
					item['title']=item['title'][0:html_begin-1] #strip
					#things mess up if a title ends in a space, so strip trailing spaces
				#doublecheck
				if len(item['title'])==0:
					item['title']='untitled'
				else:
					while item['title'][len(item['title'])-1] == ' ':
						item['title']=item['title'][0:len(item['title'])-1]
			item['title'] = self.encode_text(item['title'])
			
			if item.has_key('creator') == 0:
				item['creator']=""
			if item.has_key('author') == 1:
				item['creator']=item['author']
			if item.has_key('guid') == 0:
				item['id']=0
				item['guid']='0'
			if item.has_key('link') == 0:
				item['link'] = ""
				
			item['creator']=self.encode_text(item['creator'])
			#print item['title']+"  "+str(fake_time-i)
				
			status = self.get_status(item,existing_entries)
			#print 'status:'+str(status)
			#returns (status,entry id)
			
			if status[0]==NEW:
				#insert with fake time
				try:
				#print "inserting"
					self.c.execute(u'INSERT INTO entries (id, feed_id, title, creator, description, read, date, guid, link, old, new) VALUES (NULL, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',(feed_id,item['title'],item['creator'],item['body'],'0',fake_time-i,item['guid'],item['link'],'0','1'))
				
				except:
					pass
				self.c.execute("""SELECT id FROM entries WHERE date=?""",(fake_time-i,))
				entry_id = self.c.fetchone()[0]
				#print entry_id
				if item.has_key('enclosures'):
					for media in item['enclosures']:
						self.c.execute(u"""INSERT INTO media (id, entry_id, url, mimetype, download_status, viewed, keep, length) VALUES (NULL, ?, ?, ?, ?, ?, ?, ?)""", (entry_id, media['url'], media['type'], 0, 0, 0, media['length']))
			elif status[0]==EXISTS or status[0]==MODIFIED:
				#just clear flag
				#print "clear old flag"
				self.c.execute("""UPDATE entries SET old=0 where id=?""",(status[1],))
			i+=1
			
		#anything not set above as new, mod, or exists is no longer in
		#the xml and therefore should be deleted
		#TODO: Also delete media
	#	self.c.execute(u'SELECT old,title FROM entries WHERE feed_id=?',(feed_id,))
#		print "=-"*40
	#	print self.c.fetchall()
		self.c.execute("""DELETE FROM entries WHERE old=1 AND feed_id=?""",(feed_id,))
		self.db_lock.release()
		return SUCCESS

	def get_status(self,item,existing_entries):
		#someone please tell me how to do enums 
		#fix this
		ID=0
		GUID=1
		LINK=2
		TITLE=3
		BODY=4

		entry_id=-1
		old_hash = sha.new()
		new_hash = sha.new()
		
		for entry_item in existing_entries:
			#print "entry_item:"+str(entry_item)
			if str(item['guid'])!='0':
				#print 'g: '+str(entry_item[GUID])+' '+str(item['guid'])
				if str(entry_item[GUID]) == str(item['guid']):# and entry_item[TITLE] == item['title']:
					#print "matched on GUID"
					entry_id = entry_item[ID]
					old_hash.update(str(entry_item[GUID])+str(entry_item[BODY]))
					new_hash.update(str(item['guid'])+str(item['body']))
					break
			elif item['link']!='':
				#print "matched on link"
				if entry_item[LINK] == item['link'] and entry_item[TITLE] == item['title']:
					entry_id = entry_item[ID]
					old_hash.update(str(entry_item[LINK])+str(entry_item[BODY]))
					new_hash.update(str(item['link'])+str(item['body']))
					break
			elif entry_item[TITLE] == item['title']:
				#print "matched on title"
				entry_id = entry_item[ID]
				old_hash.update(str(entry_item[TITLE])+str(entry_item[BODY]))
				new_hash.update(str(item['title'])+str(item['body']))
				break

		if entry_id == -1:
			return (NEW, entry_id)

		if new_hash.hexdigest() == old_hash.hexdigest():
			#print 'exists'
			return (EXISTS,entry_id)
		else:
			#print 'modified'
			return (MODIFIED,entry_id)
			
	def get_entry_media(self, entry_id):
		self.db_lock.acquire()
		self.c.execute("""SELECT * FROM media WHERE entry_id = ?""",(entry_id,))
		data=self.c.fetchall()
		self.db_lock.release()
		if data: 
			dataList = [list(row) for row in data]
		else:
			return None
		media_list=[]
		for datum in dataList:
			medium={}
			medium['url']=datum[2] #MAGIC
			medium['download_status']=int(datum[5]) #MAGIC
			try:
				medium['size']=int(datum[8]) #MAGIC
			except:
				medium['size']=0
			medium['media_id']=int(datum[0]) #MAGIC
			medium['file']=datum[3] #MAGIC			
			medium['entry_id']=datum[1] #MAGIC
			medium['viewed']=int(datum[6]) #MAGIC
#			if medium['download_status'] == 1: #if downloading, get progress
			media_list.append(medium)			
		return media_list
		
	def get_media(self, media_id):
		self.db_lock.acquire()
		self.c.execute(u'SELECT * FROM media WHERE id=?',(media_id,))
		datum=self.c.fetchone()
		self.db_lock.release()
		medium={}
		medium['url']=datum[2] #MAGIC
		medium['download_status']=int(datum[5]) #MAGIC
		try:
			medium['size']=int(datum[8]) #MAGIC
		except:
			pass
		medium['media_id']=media_id
		medium['file']=datum[3] #MAGIC
		medium['entry_id']=datum[1] #MAGIC
		medium['viewed']=int(datum[6]) #MAGIC
		return medium
	
	def get_entry(self, entry_id):
	#	print "locking for get_entry"
		self.db_lock.acquire()
		#print "locked"
		self.c.execute("""SELECT title, creator, link, description, feed_id FROM entries WHERE id=?""",(entry_id,))
		result = self.c.fetchone()
		self.db_lock.release()
		entry_dic={}
		try:
			entry_dic['title'] = result[0]
			entry_dic['creator'] = result[1]
			entry_dic['link'] = result[2]
			entry_dic['description']=result[3]
			entry_dic['feed_id']= result[4]
			entry_dic['entry_id'] = entry_id
		except TypeError: #this error occurs when feed or item is wrong
			raise NoEntry, entry_id, "no such entry"
		return entry_dic
		
	def get_entrylist(self, feed_index):#, username):
		#returns feed_id, title
		#not polling by default anymore
		#try:
		#	self.poll_feed(feed_index)
		#except NoFeed:
		#	pass
		self.db_lock.acquire()
		self.c.execute("""SELECT id,title,date, new FROM entries WHERE feed_id=? ORDER BY date DESC""",(feed_index,))
		result = self.c.fetchall()
		self.db_lock.release()
		if result=="":
			raise NoFeed, feed_index
		#result[1] = self.decode_text(result[1])
		return result

	def get_feedlist(self):
		self.db_lock.acquire()
		self.c.execute("""SELECT id,title FROM feeds ORDER BY title""")
		result = self.c.fetchall()
		self.db_lock.release()
		if result: 
			dataList = [list(row) for row in result]
		else:
			result=[]
#		for item in dataList:
#			item[1] = self.decode_text(item[1])
		return dataList
		
	def get_feed_title(self, feed_index):
		self.db_lock.acquire()
		self.c.execute("""SELECT title FROM feeds WHERE id=?""",(feed_index,))
		try:
			result = self.c.fetchone()[0]
		except TypeError:
			self.db_lock.release()
			raise NoFeed, feed_index	
		self.db_lock.release()
		#don't return a tuple
		return result #self.decode_text(result)
		
	def set_feed_name(self, feed_id, name):
		name = self.encode_text(name)
		self.db_lock.acquire()
		if name is not None:
			self.c.execute(u'UPDATE feeds SET title=? WHERE id=?',(name,feed_id))
			self.db_lock.release()
		else:
			self.c.execute("""SELECT url FROM feeds WHERE id=?""",(feed_id,))
			url=self.c.fetchone()[0]
			self.db_lock.release()
			try:
				feedparser.disableWellFormedCheck=1
				data = feedparser.parse(url)
			except:
				return
			channel=data['channel']
			print channel
			if channel.has_key('title') == 0:
				if channel['description'] != "":
					channel['title']=channel['description']
				else:
					channel['title']=url
			channel['title'] = self.encode_text(channel['title'])
			self.db_lock.acquire()
			self.c.execute(u'UPDATE feeds SET title=? WHERE id=?',(channel['title'],feed_id))
			self.db_lock.release()
		
	def set_read(self, entry_id):
		self.db_lock.acquire()
		self.c.execute("""UPDATE entries SET new=0 WHERE id=?""",(entry_id,))
		self.db_lock.release()
		
	def set_media_download_status(self, media_id, status):
		self.db_lock.acquire()		
		self.c.execute(u'UPDATE media SET download_status=? WHERE id=?', (status,media_id,))
		self.db_lock.release()
		
	def set_media_filename(self, media_id, filename):
		self.db_lock.acquire()
		self.c.execute(u'UPDATE media SET file=? WHERE id=?', (filename,media_id))
		self.db_lock.release()
		
	def set_media_viewed(self, media_id, viewed=1):
		self.db_lock.acquire()
		self.c.execute(u'UPDATE media SET viewed=? WHERE id=?',(int(viewed),media_id))
		self.db_lock.release()
		
	def set_entry_new(self, entry_id, new):
		self.db_lock.acquire()
		self.c.execute(u'UPDATE entries SET new=? WHERE id=?',(int(new),entry_id))
		self.db_lock.release()
		
	def set_entry_read(self, entry_id, read):
		self.db_lock.acquire()
		self.c.execute(u'UPDATE entries SET read=? WHERE id=?',(int(read),entry_id))
		self.db_lock.release()
		
	def get_entry_read(self, entry_id):
		self.db_lock.acquire()
		self.c.execute(u'SELECT read FROM entries WHERE id=?',(entry_id,))
		retval = self.c.fetchone()[0]
		self.db_lock.release()
		return int(retval)
		
	def clean_media_status(self):
		self.db_lock.acquire()
		self.c.execute(u'UPDATE media SET download_status=0 WHERE download_status<>2')
		self.db_lock.release()
	
	#def get_media_download_status(self, media_id):
	#	self.db_lock.acquire()
	#	self.c.execute(u'SELECT download_status FROM media WHERE id=?', (media_id,))
	#	self.db_lock.release()
	#	return int(self.c.fetchone()[0])
		
	def get_entry_download_status(self, entry_id):
		self.db_lock.acquire()
		self.c.execute(u'SELECT media.download_status, media.viewed FROM media,entries WHERE media.entry_id=entries.id AND media.download_status!=0 AND entries.id=?',(entry_id,))
		result = self.c.fetchall()
		#if entry_id==262:
		#	print result
		self.db_lock.release()
		if result: 
			dataList = [list(row) for row in result]
		else:
			return 0
	#	if entry_id==262:
	#		print datum
		for datum in dataList:
			if int(datum[0])==1:
				return 1
			#if int(datum[0])==2 and int(datum[1])==True: #if viewed, return true
			#	return 0
			if int(datum[0])==-1:
				return -1
			#return 1 if any are downloading, 2 if all are complete, zero otherwise
		#		print "returning 2"
		return 2		
		
	def get_feed_download_status(self, feed_id):
		entrylist = self.get_entrylist(feed_id)
		for entry in entrylist:
			status = self.get_entry_download_status(entry[0])
			if status==-1:
				return -1
			if status==1:
				return 1
			if status==2:
				return 2
		return 0
		
	def get_entry_flags(self, entry_id):
		
			#  54321
			
			
			
			
			
			# oh well.  this order no longer reflects reality
			# 32: error
			# 16: downloading
			#  8: unviewed
			#  4: downloaded  #**#
			#  2: new
			#  1: media
			
			
			
			#download failed, always bi    100000   32
			#downloading, always i         010000   16
			#downloaded new   unviewed     001111   15
			#downloaded old   unviewed     001101   13
			#undownloaded new unviewed     001011   12
			#undownloaded old unviweed     001001   9
			#downloaded not-unviewed       000100   4
			#text new                      000010   2
			#undownloaded not-unviewed     000001   1
			#text old                      000000   0
		
		printstuff=0
		#if entry_id==262:
		#	printstuff=1
		importance=0
		status = self.get_entry_download_status(entry_id)
		self.db_lock.acquire()
		self.c.execute(u'SELECT new,read FROM entries WHERE id=?',(entry_id,))
		temp = self.c.fetchone()
		new=temp[0]
		read=temp[1]
		self.db_lock.release()
			
		medialist = self.get_entry_media(entry_id)
		
		if status==-1:
			if printstuff:
				print "error"
			importance=importance+F_ERROR
		if status==1:
			#if printstuff:
			#print "downloading"
			importance=importance+F_DOWNLOADING
		
		if new==1:
			if printstuff:
				print "new"
			importance=importance+F_NEW
				
		if medialist:	
			if printstuff:
				print "media"
			importance=importance+F_MEDIA
			if printstuff:
				print "status: "+str(status)
			if status==2:
				if printstuff:
					print "downloaded: "+str(entry_id)
				importance=importance+F_DOWNLOADED
			#for medium in medialist:
			medium=medialist[0]
			if medium['viewed']==0:
				if printstuff:
					print "unviewed"
				importance=importance+F_UNVIEWED
		else:
			if int(read)==0:
				importance=importance+F_UNVIEWED
		
		#print "total: "+str(importance)
		return importance		
				
	def DEBUG_get_full_feedlist(self):
		self.c.execute("""SELECT id,title,url FROM feeds ORDER BY id""")
		result = self.c.fetchall()
		return result
		
	def encode_text(self,text):
		return text.encode('utf8')
	
	#def decode_text(self,text):
		#return unicode(text)
	
class NoFeed(Exception):
	def __init__(self,feed):
		self.feed = feed
	def __str__(self):
		return "No such feed: "+self.feed
		
class NoEntry(Exception):
	def __init__(self,entry):
		self.entry = entry
	def __str__(self):
		return "No such entry: "+self.entry
		
class NoSetting(Exception):
	def __init__(self,setting):
		self.setting = setting
	def __str__(self):
		return "No such entry: "+self.setting
		
class NoUser(Exception):
	def __init__(self,user):
		self.user = user
	def __str__(self):
		return "No such user: "+self.user
		
class DBError(Exception):
	def __init__(self,error):
		self.error = error
	def __str__(self):
		return "Error connecting to database: "+self.error
